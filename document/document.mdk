[INCLUDE=presentation]
Title         : Justification Logic
Sub Title     : A Curry- Howard View
Title Note    : Amazon JFK presentation
Author        : Konstantinos Pouliasis
Affiliation   : The Graduate Center, City Univesity of New York
Email         : pouliasi@amazon.com, konstantinos.pouliasis@gmail.com, 
Reveal Theme  : solarized
Beamer Theme  : madrid
Package     : mathpartir.sty
Package       : mathtools
Bib style     : plainnat
Bibliography  : secondexam.bib

[TITLE]



#Introduction
 
## CURRY--HOWARD ISO 

* the connection of  proofs constructs in intuitionistic logic and programs of simple typed lambda calculus 

* central topic of study in the field of type theory 

* standard theoretical tool for  study, design  and prototyping programming languages  

## Curry--Howard in logic
* a new paradigm in logic studies that emphasizes _proof relevance_

* _ scales_ : the isomorphism holds for more complex logics and 
  correspondingly captures complex programming language constructs.  

* We use  _proofs-as-programs_(-as-morphisms) and __CHI__ interchangeably.

* The relation of proofs, programs and categories (morphisms)  has renewed interest in foundations (HoTT)

## Roadmap of this presentation
 * Concepts and scalable proof techiques of __CHI__ 
 
      * intuitionistic propositional logic (__IPL__)/ simply typed lambda calculus (__STLC__)
 
 *  My work on exploring a Curry-Howard reading of basic _Justification Logic_(__JL__) and its programmistic
 interpretation
  

# IPL and STLC 


## Intuitionism and constructive mathematics

  * Notion of truth collides with the notion of proof 

  * Continuation of Brouwer's program 

  * Mathematical reasoning -- and logic -- is a human faculty

  * The creative subjects use mathematical language to as a means to 
express  their reasoning (proof) constructs   

  * Propositions do not come with a pre-existing truth value: There are open problems!




## Intuitionistic/ type theoretic Foundations 

 * Proofs are stand alone objects and not metamathematical constructions

 * NOT strings, sequences or godelizations of some _fixed_ formal system

 * Mathematical objects such as __Nat__ with the primitive recursive function space
 are  obtained as models of (proof objects) for equational proof theories 
 
 * (e.g. a typed version of Godel's __T__ in the case of __Nat__ with primitive recursion). 

## Logic within intuitionism

 * The object of logic is the study of "sane" proof constructs

 * The traditional chasm between "syntax" and "semantics" is no longer  very fruitful idea
  at least when "engineering" new logics.

 * "The meaning of a connective is the ways that one can prove it " (Martin Lof - Verificationist approach)


# Natural Deduction and judgments

## Judgments

* Logic defines _judgments_ ("sane" deductions in a specific domain)

* In intuitionistic propositional logic (__IPL__)   __judgments__ we have judgments of two  kinds:
  * $A\  {\sf Prop}$: $A$ is in the universe of propositions
  * $A\  {\sf true}$ : $A$ has a proof
  
* $A\  {\sf Prop}$: can be replaced with a context free grammar in the propositional case.
But in general that's not the case. E.g. $\forall x. A(x)$ is not even a type whereas $\forall x:B. A(x)$
is only when $x:A\vdash B(x):{\sf Prop}$

* Other logics implement different judgments/ modalities (e.g.  ${\sf A \ true \ at \ t}$ )




## Hypotheticals

Judgment construction can be presented in tree form 

~ Math
  
  {\begin{array}{c}
  {J_1 \ldots J_i}  \\
  \vdots \\
  {J} 
  \end{array} } 
~ 


the root ($J$) is the deduced judgment

and leafs (   ${J_1 \ldots J_i}$) are hypothesized judgments


## Hypotheticals
  * we will be concerned with $J$ of the form ${\sf A \ true}$
  
  * hypotheses are  labeled with unique tags 
  
  * since we focus only on judgments   we will omit the "kinding"
  and write simply $A$.




##Rules of Inference: Hypotheses
 Hypotheses can be trivially reflected. I.e.  

 
  ~ Math
  {\begin{array}{c}
    {\text For\  } k \in [1\ldots i]\\
    \\
  {x_1:A_1  \ldots x_i: A_i}  \\
  \vdots \\
  {x:A_{k}} 
  \end{array} } 
  ~


## Inference: Conjunction

   ~ Math
  \inferrule*[right=Intro] {
 {\begin{array}{c}
  \mathcal{D}
  {A} 
  \end{array} } \\{\begin{array}{c}
  \vdots \\
  {B} 
  \end{array} }} {A\wedge B}
  ~


  ~ Math
    \begin{array}{c c}
  \inferrule*[right=Elim1] {
 {\begin{array}{c}
   \\
  \vdots \\
  {A\wedge B} 
  \end{array} }} {A} & \inferrule*[right=Elim2] {
 {\begin{array}{c}
   \\
  \vdots \\
  {A\wedge B} 
  \end{array} }} {A}
  \end{array}
  ~

## Equality and Harmony

Proof trees are objects of logic and - as mathematical objects -  are equipped with _equality_

~ Center
__Logic is "algebrized"__
~

Equalities should provide for the "harmony" of the Introduction 
-- Elimination constructions-- destructions

## Harmony in Slogans

~ Center
["Elimination Rules are not too strong"]{ color=red }
~
Introducing  a connective just to eliminate it won't give anything new. 

~ Center
["Elimination Rules are not too weak"]{ color=blue }
~
 You should have "enough" elimination techniques to reintroduce a connective using introductions.

~Begin Vertical
## Harmony Conjunction

~Center 
Local Soundness 
~
  ~ Math
    \begin{array}{l c r}
  {\inferrule*[right=Elim1]{\inferrule*[right=Intro] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A} 
  \end{array} } \\{\begin{array}{c}
  \mathcal{E} \\
  {B} 
  \end{array} }} {A\wedge B}}{A}} & = &   
   {\begin{array}{c}
  \mathcal{D}\\
  {A} 
  \end{array} }
  \end{array}
  ~ 


## Harmony Conjunction
~Center 
Local Soundness 
~
  ~ Math
    \begin{array}{l c r}
  {\inferrule*[right=Elim2]{\inferrule*[right=Intro] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A} 
  \end{array} } \\{\begin{array}{c}
  \mathcal{E} \\
  {B} 
  \end{array} }} {A\wedge B}}{B}} & = &   
   {\begin{array}{c}
  \mathcal{E}\\
  {A} 
  \end{array} }
  \end{array}
  ~ 

## Harmony Conjunction
~ Center
Local Completeness
~

 ~ Math
\begin{array}{l c r}
   {\begin{array}{c}
  \mathcal{D}\\
  {A\wedge B} 
  \end{array} } & =  &  {\inferrule*[right=Intro]{{\inferrule*[right=Elim1] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A\wedge B} 
  \end{array} } } {A}}\\
  {\inferrule*[right=Elim2] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A\wedge B} 
  \end{array} } } {B}}}{A\wedge B}}
  \end{array}
  ~ 
~ End Vertical

## Top
$0$-ary conjunction

~ Math
\inferrule*[right=Intro]{ }{\top}
~

No elimination rule: You cannot extract any data from no data!

Local Soundess trivial (no elim)

Local Completeness:
~ Math
\begin{array}{l c r}
\inferrule*[right=Intro]{\mathcal{D} }{\top} & = & \inferrule*[right=Intro]{}{\top} 
\end{array}
~



## Implication

As conjunctions internalize "pairing", implication internalizes hypothetical reasoning.

~ Math
  \begin{array}{c}
 {\inferrule*[right=Intro] {
 {\begin{array}{c}
  x_1:A_i \ldots \overline{x:A}\\
  \vdots \\
  {B} 
  \end{array} } } {A\supset B}} 
 \\
 \\
 {\inferrule*[right=Elim] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A\supset B} 
  \end{array} }\\ {\begin{array}{c}
  \mathcal{E}\\
  {A} 
  \end{array} } } {B}}
 \end{array}
~


## Harmony: Implication

~ Center 
  Local Soundness
~

~ Math
  \begin{array}{c c c}
  {\inferrule*{
{\inferrule*[right=Intro]
{
 {\begin{tabular}[b]{c}
 $\overline{x:A}$
  \\
  $\mathcal{D}$
  \\
  $B$
 \end{tabular}} \\
 \\
}
{A\supset B}}\\{\begin{tabular}[b]{c}
  $\mathcal{E}$
  \\
  $A$
 \end{tabular}}} {B}} & = & {\begin{tabular}[b]{c}
  $\mathcal{E}$
  \\
  $A$
  \\
  $\mathcal{D}$\\
  $B$
\end{tabular}}
 \end{array}
~





## Harmony : Implication

~ Center 
  Local Completeness
~

~ Math
	\begin{array}{c c c}
    {\begin{array}[b]{c}  {\mathcal{D}} \\ A\supset B  \end{array}} & = &
		{\inferrule{
				{\inferrule[]{
						{\begin{array}[b]{c}  {\mathcal{D}} \\ A\supset B  \end{array}}\\{\overline{x:A}}} { B }}}{A \supset B}
			}
		
		
		
	\end{array}
~
~ Begin Vertical
## Disjunction

~ Math
\begin{array}{l c}
  \inferrule*[right=intro1]{A}{A\vee B} &   \inferrule*[right=intro2]{B}{A\vee B}\\
\\
\inferrule*[right=elim$^{x,y}$] {{\begin{tabular}[b]{c}
  $\mathcal{D}$
  \\
  $A\vee B$
 \end{tabular}}\\ 
  { {\begin{tabular}[b]{c}
 $\overline{x:A}$
  \\
  $\mathcal{E}$
  \\
  $C$
 \end{tabular}}}\\
  { {\begin{tabular}[b]{c}
 $\overline{y:B}$
  \\
  $\mathcal{F}$
  \\
  $C$
 \end{tabular}}}}{C}
 \end{array}
~

## Disjunction: Harmony

~ Center
Local Soundness
~

~ Math
\begin{array}{l c r }
\inferrule*[right=elim$^{x,y}$] {{\begin{tabular}[b]{c}
  $\mathcal{D}$
  \\
  $A$\\
  \hline 
  $A\vee B$
 \end{tabular}}\\ 
  { {\begin{tabular}[b]{c}
 $\overline{x:A}$
  \\
  $\mathcal{E}$
  \\
  $C$
 \end{tabular}}}\\
  { {\begin{tabular}[b]{c}
 $\overline{y:B}$
  \\
  $\mathcal{F}$
  \\
  $C$
 \end{tabular}}}}{C} &=& {\begin{tabular}[b]{c}
 $\mathcal{D}$\\
 $A$\\
 $\mathcal{E}$\\
  $C$
 \end{tabular}}
\end{array}
~



## Disjunction: Harmony
~ Center
Local Soundness
~
~ Math
\begin{array}{l c r }
\inferrule*[right=elim$^{x,y}$] {{\begin{tabular}[b]{c}
  $\mathcal{D}$
  \\
  $B$\\
  \hline 
  $A\vee B$
 \end{tabular}}\\ 
  { {\begin{tabular}[b]{c}
 $\overline{x:A}$
  \\
  $\mathcal{E}$
  \\
  $C$
 \end{tabular}}}\\
  { {\begin{tabular}[b]{c}
 $\overline{y:B}$
  \\
  $\mathcal{F}$
  \\
  $C$
 \end{tabular}}}}{C} &=& {\begin{tabular}[b]{c}
 $\mathcal{D}$\\
 $B$\\
 $\mathcal{F}$\\
  $C$
 \end{tabular}}
\end{array}
~

## Disjunction: Harmony

~ Center
Local Completeness
~

~ Math
\begin{array}{c c}
  {\begin{array}{c}  \\ \inferrule*{\mathcal{D}}{A\vee B} \end{array}} & =
\end{array}
~

~ Math
\begin{array}{c r}
  \\
\inferrule*[right=E$^{\overline{x},\overline{y}}$] {
  {\begin{array}{c}  \\ \inferrule*{\mathcal{D}}{A\vee B} \end{array}}\\ 
  {\begin{array}{c} \\ \inferrule*[right=I1]{\overline{x:A}}{A\vee B} \end{array}}\\
  {\begin{array}{c} \\ \inferrule*[right=I2]{ \overline{y:B}}{A\vee B} \end{array}}
   }{A\vee B} & = 
\end{array}
~
~End Vertical


## Bottom

~ Math 
\inferrule*[right=Elim]{\bot}{A}
~
~ Center
NO INTRO RULE
~

~ Center
local soundness: Trivial (No intro)

local completeness:
~

~ Math
  {\begin{array}{l c r}  \\ \inferrule*{\mathcal{D}}{\bot} & = & \inferrule*{\inferrule*{\mathcal{D}}{\bot}}{\bot} \end{array}} 
~




## Proof Trees To Terms (STLC): Contexts

* Proof trees transliterate to (one dimensional) proof terms constructions
of the simply typed lambda calculus as do equalities. 

* Labeled hypotheses become _typed variable contexts_ (scopes) which can be reflected freely
at any point in proof term constructions.
* Similarly to well typed program formation  in programming languages. Sequent construction
corresponds to type checking.

~ Math
\inferrule*{{\inferrule*{ }{x:int\vdash x:int}}\\{\inferrule*{ }{x:int\vdash 1:int}}}{x:int\vdash x+1:int}
~ 

##STLC : Contexts
For reasons similar to ${\sf Prop}$, context formation also becomes a judgment.

~ Math
\inferrule*[right=Empty]{ }{\bullet \vdash {\sf ctx}}
~
~Math
\inferrule*[right= Cons] {\Gamma\vdash {\sf ctx}\\ \Gamma\vdash A {\sf\  Prop}\\ x\not\in Dom(\Gamma)  }
{\Gamma,x:A\vdash {\sf ctx}}
~ 

* As labels are "pluggable" tree slots, variables are substitutable for terms of 
appropriate type

* Similarly to typed arguments in a functions declaration.
* One should always prove this substitution principle as a metatheorem :

$\Gamma,x:A\vdash N:B \text{\ and }\Gamma\vdash M:A \Longrightarrow \Gamma\vdash M[N/x]:B $ 

## CONJUNCTION AS PRODUCT
Intro rules transliterate to data constructor declarations
ti SKATA???




## Allo
 
 Transcribes to: 
 

## CONJUNCTION AS PRODUCT

Similarly for elimination

~ Math
  \begin{array}{c }
  {\inferrule*[right=Elim1]
    {\Gamma\vdash  M : A\times B}
    {\Gamma\vdash fst(M):A}} \\ 
    \\
    {\inferrule*[right=Elim2]
    {\Gamma\vdash  M : A\times B}
    {\Gamma\vdash snd(M):B}}
   \end{array}
~

~ Begin Vertical

## CONJUNCTION HARMONY

The local soundness and completeness give the local reduction ($\beta$) 
and expansion ($\eta$) rules

 ~ Math
    \begin{array}{l c r}
  {\inferrule*[right=Elim]{\inferrule*[right=Intro] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A} 
  \end{array} } \\{\begin{array}{c}
  \mathcal{E} \\
  {B} 
  \end{array} }} {A\wedge B}}{A}} & = &   
   {\begin{array}{c}
  \mathcal{D}\\
  {A} 
  \end{array} }
  \end{array}
 ~ 

  ~ Math
   \Gamma\vdash fst (\langle M, N \rangle) =_{\beta} M: A
   ~ 
  And similarly 
  
~ Math
\Gamma\vdash snd (\langle M, N \rangle) =_{\beta} N:B
~

## Conjunction: Harmony

$\eta$ expansion is given analogously
Proof tree equality 
 ~ Math
\begin{array}{l c r}
   {\begin{array}{c}
  \mathcal{D}\\
  {A\wedge B} 
  \end{array} } & =  &  {\inferrule*[right=Intro]{{\inferrule*[right=Elim1] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A\wedge B} 
  \end{array} } } {A}}\\
  {\inferrule*[right=Elim2] {
 {\begin{array}{c}
  \mathcal{D}\\
  {A\wedge B} 
  \end{array} } } {B}}}{A\wedge B}}
  \end{array}
  ~
translates to
~ Central
$\Gamma\vdash M = \langle fst(M), snd(M)\rangle :A \wedge B$
~

~ End Vertical

## Implication as function space

~ Math
  \begin{array}{c }
  {\inferrule*[right=Intro]
    {\Gamma,x:A\vdash  M : A}
    {\Gamma\vdash \lambda x:A. M:A\supset B}} \\ 
    \\
    {\inferrule*[right=Elim]
    {{\Gamma\vdash  M : A \supset B}\\
    {\Gamma\vdash N:A}}{\Gamma\vdash (MN):B}}
   \end{array}
~
Harmony gives the  $\beta\eta-$ equalities 
Similarly we obtain the whole equational system of the STLC
$(\lambda x: A. M) N =_{\beta} M[N/x]$

$f:A \supset B = \lambda x:A. f x$

## Disjunction as union 
~ Math
  \begin{array}{c }
  {\inferrule*[right=Intro1]
    {\Gamma\vdash  M : A}
    {\Gamma\vdash  inl^{B}(M):A\vee B}} \\ 
    \\
    {\inferrule*[right=Intro2]
    {\Gamma\vdash  M : B}
    {\Gamma\vdash inr^{A}(M):A\vee B}}
    \\
    \\
    {\inferrule*[right=Elim]{{\Gamma\vdash M:A\vee B}\\{\Gamma,x:A\vdash N:C}\\ {\Gamma,y:B\vdash O:C}} { {\Gamma}\vdash {\text{case }M \text{ of } inl( x)\longmapsto N  |\  inr (y)\longmapsto O : A\vee B}}}
   \end{array}
~

## Disjunction as union
Again the "meaning" of the terms is embedded in the equalities that witness harmony given by Gentzen's principles:

~Math
\alpha 
~

re gav!!



## Consistency Results
_Issue_: How do you show that this calculus does not prove $\bot$

Problem with straightforward induction on trees: Proofs are not canonical, no subformula property.

_Foundational Problem_: The meaning of a proposition depends on itself ($A$ depends on $B\supset A$ and $B$). 
Circularity.

__Verificationism to the rescue__: _The meaning of a connective is the set of its ~~proofs~~  verifications. Informally:
straightforward ways to prove it_



## Calculus of verifications
Goal : Create a calculus in which  all proofs are "normal" 

A verification should be a proof that only analyzes the constituents of a proposition

Show that for every proof in natural deduction there is a unique verification and moreover $\beta\eta$ equal proofs
have the same verification. 

We create a "restricted" natural deduction for verifications and show that it is complete.

## Calculus of verifications
Two judgments 

* $A\uparrow$ can be read as "$A$ has a verification" or "$A$ is canonically proven"
* $A\downarrow$ can be read as "$A$ can be extracted  canonically (via elims) from assumptions", "$A$ has a canonical extraction".

Judgments have the forms:


~ Math
\begin{array}{c  c}
	{\begin{array}{c}
		{A_1\downarrow \ldots A_i\downarrow}  \\
		\vdots \\
		{A\uparrow}\end{array}} & {\begin{array}{c}
		{A_1\downarrow \ldots A_i\downarrow}  \\
		\vdots \\
		{A\downarrow}\end{array}}  
	\end{array} 
~
## Verifications: Basic Idea
One should think the arrows as directing (canonical) proof search. Intro rules guide search  bottom up, Elim rules guides search from top (assumptions) down. When arrows can meet we have  a normal proof.

__Canonicity applies Gentzen's principles directly__ 

* canonical proofs should not go through "roundabouts" (elim-after intro) 
i.e. the terms should not have $\beta$ redexes.

* assumptions are forced  to  a have certain shape based on their types (i.e. $\eta$ expansion) 


## Canonical Conjunction -- Truth
~ Math
  \inferrule*[]
  { {A \uparrow}\\{B\uparrow}} 
  { A\wedge B\uparrow}
~

~ Math
  \begin{array}{c c}
  {\inferrule*[]
  { {A \wedge B\downarrow}} 
  { A \downarrow}} &
  {\inferrule*[]
  { {A \wedge B\downarrow}} 
  {  B\downarrow}}
  \end{array}
~

~ Math
	\inferrule*{ }{\top\uparrow} 
~

## Hypotheses
~ Math
  \inferrule*[right=Atomic Hyp]
  {x:P_i\downarrow } 
  {P_i\uparrow }
~
The reflection can be restricted only to atomic formulas. 
This way the proof of consistency also "justifies" $\eta$ equality (global completeness). 


The general rule below is _admissible_ and the recipe of the proof essentially applies $\eta$-expansion principles based on the structure
of $A$:

~ Math
  \begin{array}{c}
  \inferrule*[vdots=1.5em]
  {x:A\downarrow } 
  {}
  \\
  \inferrule*{}{A\uparrow}
  \end{array}
~

## Canonical Implication 

~ Math
  \begin{array}{c}
 {\inferrule* {
 {\begin{array}{c}
  x_1:A_1\downarrow \ldots \overline{x:A\downarrow}\\
  \vdots \\
  {B\uparrow} 
  \end{array} } } {A\supset B\uparrow}} 
 \\
 \\
 {\inferrule* {
 {\begin{array}{c}
  {A\supset B\downarrow} 
  \end{array} }\\ {\begin{array}{c}
  {A\uparrow} 
  \end{array} } } {B\downarrow}}
 \end{array}
~


## Examples
Here are the (two) verifications  of $P\supset( P\supset P)$

~ Math
	\inferrule*[right=$\supset^{x}$]
	{\inferrule*[right=$\supset^{y}$]{
			{} \\{\inferrule*[right=Refl$^{y}$]{\overline{x:P},\overline{y:P}\downarrow}
				{y:P\uparrow}}}{P\supset P}}
	{P\supset(P\supset P)}
~

~ Math
	\inferrule*[right=$\supset^{x}$]
	{\inferrule*[right=$\supset^{y}$]{
			{} \\{\inferrule*[right=Refl$^{x}$]{\overline{x:P},\overline{y:P}\downarrow}
				{x:P\uparrow}}}{P\supset P}}
	{P\supset(P\supset P)}
~
Corresponding to $\lambda x:P.\lambda y:P. y$ and $\lambda x:P.\lambda y:P. x$

## Absurd
If $\bot$ is extracted it proves anything.
~ Math
\inferrule*{\bot\downarrow}{A\uparrow}
~

## Properties : Soundness w.r.t Nat Deduction




*  Any (tree) judgment of shape $\Gamma\downarrow\  \vdash A\uparrow$ 
is trivially a natural deduction (tree) judgment $\Gamma \vdash {\sf A \ true}$ 
 (via forgetful inclusion)

* Any judgment $\Gamma\ \downarrow\ \vdash A\downarrow$ is trivially a natural deduction judgment 
$\Gamma \vdash {\sf A\  true}$
     (similarly)

## Properties: Completeness w.r.t Nat Deduction

~ Math
  \begin{array}{c c}
{\inferrule*[right=Coercion]{A\uparrow}{A\downarrow}} & {\inferrule*{A\downarrow}{A\uparrow}}
\end{array}
~

* Adding coercion and unrestricted reflection ($\Gamma\downarrow\ \vdash^{+}$ ) trivially gives completeness. 

* Coercion permits for trees where a connective is introduced only to be eliminated which were initially banned for verifications ( equivalently lambda terms with $\beta$-redexes)

* For every tree $\mathcal{D}$ : $\Gamma\vdash A \ {\sf true}$ there exists
	a $\mathcal{\overline{D}} : \Gamma\downarrow\vdash^{+} A\uparrow$
(trivially)

* Unrestricted reflection is admissible as we sketched.

*	__Goal__ : Show admissibility of coercion as well

## Properties: Completeness w.r.t Nat Deduction

We want to show:

~ Math
\Gamma\downarrow\ \vdash^{+}A\uparrow \ \equiv\  \Gamma\downarrow\ \vdash A\uparrow
~ 

Induction in bi-directional trees is inconvenient.

But we have another trick : Sequent Calculus! 


Under Curry -- Howard analysis,  sequent calculus is not yet another  axiom system but an (one-dimensional) encoding of canonical annotated deductions!
{ margin-right:2em; \
  padding:1.0em; \
  background-color:floralwhite; \
  background-clip: padding-box; \
  border: 0.5ex solid black; \
  border-radius: 4ex; \
  width: 22.2em;\
}


## Completeness Via Sequent Calculus

~ Central
__Main Ideas__
~

* Extraction rules (downwards from hypotheses via elim) are embedded to left rules

* Verifications (upwards for canonical proof search via intro) become right rules.

*  Sequents of the form $\Gamma\Rightarrow A$ are declarations of trees of shape $\Gamma\downarrow\Rightarrow A\uparrow$

## Sequent calculus from annotations

~ Math
	\inferrule*{ }{\Gamma,P\Rightarrow P}
~
~ Math
\inferrule*{{ \Gamma\Rightarrow A}\\{\Gamma\Rightarrow B}}{\Gamma\Rightarrow A\wedge B}
~
~ Math
\begin{array}{c c}{\inferrule*{\Gamma,A \Rightarrow C}{\Gamma,A\wedge B\Rightarrow C}} &{\inferrule*{\Gamma,B \Rightarrow C}{\Gamma,A\wedge B\Rightarrow C}}\end{array}
~

~ Math
\begin{array}{c c}{\inferrule*{\Gamma,A \Rightarrow B}{\Gamma \Rightarrow A\supset B}} &{\inferrule*{{\Gamma,A\supset B,B \Rightarrow C}\\{\Gamma,A\supset B\Rightarrow  A}}{\Gamma,A\supset B\Rightarrow C}}\end{array}
~

~ Math
\begin{array}{c c}{\inferrule*{ }{\Gamma\Rightarrow \top}} &{\inferrule*{ }{\Gamma,\bot\Rightarrow C}}\end{array}
~

~ Slide

Finally we show:
	* $\Gamma\downarrow\ \vdash A\uparrow\  \equiv \  \Gamma\Rightarrow  A$ (induction)
  
	* $\Gamma\downarrow \vdash^{+} A\uparrow \ \equiv\ \Gamma \Rightarrow^{+} A$
	
  *  $\Rightarrow^{+}$ is $\Rightarrow$ adjoint with:
	
	
  * $\inferrule*[right=Cut]{\Gamma\Rightarrow A}{\Gamma,A\Rightarrow C}$ 
	
  * Coercion corresponds to Cut Rule
	
  * Cut elimination shows $\Gamma\Rightarrow^{+} A \ \equiv \Gamma\Rightarrow A $ (proof by nested induction)
	
  * As a result coercion is admissible
  
  * All natural deduction proof trees have a unique  normal form
     since $\mathcal{D}:\Gamma\vdash A$  $\Gamma$
  
  * To show admissibility of Coercion we show admissibility of Cut instead.
~

## Merrits of CHI

* The ideas of separating judgments and propositions, defining connectives orthogonally, reading logic operationally 
is the main lesson of the field.

* It scales! (Linear logic, Modal logics, Substructural logics etc)


* Even for ``logics" that where not existing (System $F$)

* It gives foundations for different programmistic features - hopefully useful :)

* Fits the bill for  ``logic" as an operating system with many apps!

## IPL as proof-irrelevant natural deduction

# My proposal



## Which Justification Logic?

  * Justification logic is a multifaceted system of necessity
  * Can be configured to emulate $K$, $T$, $S4$, $S5$ modality
  * Can appear in intuitionistic and classical versions with respect to the underlying logic 
  * We focus on a minimal system based on $K$ modal logic and intuitionistic implication
  * Strengthening of the modality can be done in a way  that is respecting the computational reading we propose 




  
## Motivation


  * Justification logic stemmed from Artemov's solution to providing an explicit classical provability semantics 
  to intuionistic logic.
  * We treat justifications as __validations__. I.e. second level proof constructs 
  in a trusted system that are to be related with proof constructs of another weaker system in the first level 
  (take  intuitionistic/ classical constructs as an exemplary case)
  * We, effectively, treat __proof theoretically__ a pretty basic __semantical__ idea.    





## Motivation (formally) 

Assume deductive systems $I$:

  * with propositions in $U_I$
  * a possibly non-empty signature of axioms $\Sigma_I$    
  * an entailment relation   $\Sigma_I;\Gamma\vdash_{I}A$
   

and  $J$ with: $U_J$, $\Sigma_J$, and $\Sigma_J;\Delta\vdash_J \phi$ respectively.  

## Deductive System Requirements

* __Reflexivity__ :
    
    * $A \in \Gamma \Longrightarrow \Gamma\vdash_{I}A$
    * $\phi \in \Delta \Longrightarrow \Delta\vdash_{J}\phi$
* __Compositionality__:  

     *  $\Gamma\vdash_I A$ __and__ $\Gamma^{\prime},A\vdash_{I} B \Longrightarrow \Gamma,\Gamma^{'}\vdash_I B $  
        $\Delta\vdash_J\phi$ __and__ $\Delta^{\prime},\phi\vdash_{J} \psi \Longrightarrow \Delta,\Delta^{'}\vdash_J \psi$ 
*  __Top elements __:

 $\Gamma\vdash_{I}\top_I $ __ and__  $\Delta\vdash_{J}\top_J $
 
 


## Interpetations and Validations
An  _interpretation for $I$_, ($\llbracket\bullet \rrbracket_J$) is a pair
$(J,\llbracket\bullet\rrbracket)$ of a deductive  system $J$ together
with a (functional) mapping $\llbracket \bullet \rrbracket: U_I\rightarrow U_J$ on propositions of $I$ into propositions of $J$ extended to multisets of 
formulae of $U_I$  s.t. 

* $\llbracket\top_I \rrbracket = \top_J$ 
*  For $\Gamma$ of  the form $A_1,\ldots, A_n$: $\llbracket\Gamma \rrbracket=\llbracket A_1  \rrbracket,\ldots,  \llbracket A_n\rrbracket$

* Given a deductive system $I$  and an  interpretation  function $\llbracket\bullet\rrbracket_J:U_I\rightarrow U_J$
 of $I$ into $J$ we define:

A _validation_ of a deduction $\Sigma_I;\Gamma\vdash_I A$ to be a deduction $\Sigma_J;\Delta\vdash_{J} \phi$ in $J$ 
such that $\llbracket A \rrbracket=\phi$ and $\Delta=\llbracket \Gamma \rrbracket $ . We will be writing
$ \llbracket \Sigma_I;\Gamma\vdash_I A\rrbracket_J$ 

## Logical Completeness
Given a deductive system $I$, we say that  $J$ is __logically complete__ under 
$\llbracket\bullet \rrbracket_J$  when  for
all purely logical deductions $\mathcal{D}$ in $I$ 
 there exists a (purely logical) validation $\mathcal{E}$ in $J$.
 i.e:
 
 
  
 
 $\forall \mathcal{D}. \ \mathcal{D}:\Gamma\vdash_I A \Longrightarrow 
 \exists\mathcal{E}: \llbracket \Gamma\vdash A\rrbracket_J$




# Judgments

## Roadmap

* Create a system with two kinds of judgments $A \ {\sf true}$ and $A\  {\sf valid}:=\  \llbracket A \rrbracket {\sf true}$ and treat necessity
as "double theoremhood"  
* obtain a system of basic constructive modality investigating the minimal relation
between these two systems 
* Use justification logic to 
axiomatize validity $\llbracket \sf {judgments}\rrbracket$. 


## Modal Rule

One modal rule for elimination and introduction to relate judgments $A\  {\sf valid}$, $ A\ {\sf true}$, $ \Box A {\sf true}$: 

~ Math
  
  \inferrule* {{\Box A} \\  {\inferrule* {}{{\begin{array}{c}
  \overline{x:A}  \\
  \vdots \\
  {B} 
  \end{array} } \\ {\begin{array}{c}
  \overline{s:\llbracket A  \rrbracket} \\
  \vdots \\
  \llbracket B \rrbracket  
    \end{array}}  }}}
    {\Box B}
 ~ 
## Modal Rule (Generically)

Or, generalizing for assumptions 

$\Gamma:=x_1:A_1, \ldots, x_i: A_i\  \text{and } \Delta:= s_1:\llbracket A_i \rrbracket, \ldots 
s_i:\llbracket A_i\rrbracket$: 



~ Math
  
  \inferrule* {{\Box A_1, \ldots,  \Box A_i} \\  {\inferrule* {}{{\begin{array}{c}
  \overline{\Gamma}  \\
  \vdots \\
  {B} 
  \end{array} } \\ {\begin{array}{c}
  \overline{\Delta} \\
  \vdots \\
  \llbracket B \rrbracket  
    \end{array}}  }}}
    {\Box B}
 ~ 
 
 ## Left for the thesis
 
 * investigate semantics
 
 * investigate extensions (slightly populist promise!)
 
 * implement it

## Thank you!
Thanks for looking







